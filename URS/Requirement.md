# 電子パーツ在庫管理システムの要求仕様

## 要求

* **パーツの在庫を管理したい**: 手元の電子パーツの種類と在庫を把握できるようにしたい。回路設計時に使用可能なパーツを確認したり、実装時に必要なパーツが揃っているか確認できるようにしたい。さらに買い足しのダブりを防いで無駄遣いを減らしたい。
* **必要なパーツや情報にすぐたどり着きたい**: 購入したパーツを探し回る時間をなくしたい。品番やカテゴリ、キーワードで検索できたり、結果をソートしたりして、必要なパーツに瞬時にアクセスできるようにしたい。ついでにデータシートへのリンクやメモも一緒に残しておきたい。
* **出先でも在庫確認がしたい**: 急な出先で「あのパーツ、在庫あったら買っておこうかな」というような時にも、**スマホを使って簡単に在庫状況を確認できる**ようにしたい。
* **手間やコストをかけずに実現したい**: 個人的なツールなので、サーバーの維持管理なんて面倒な作業はしたくないし、お財布に響くような利用料も払いたくない。ついでにプログラムを作る手間もかけたくないので、流行りの**Vibe Codingがどこまで機能するか**試してみたい。

---

## システム要件

### 1. Webアプリケーションとしての基本的な提供形態

このシステムは、ユーザーがWebブラウザからアクセスする**Webアプリケーション**として提供する。
* スムーズなユーザー体験を提供するため、**Single Page Application (SPA)** として構築する。
* スマートフォンを含む様々なデバイスでの利用に対応するため、**レスポンシブUI**とする。
* 対応ブラウザは**最新のChromeとSafariを基本**とする。古いバージョンやそれ以外のブラウザは、動作を保証せず、サポート対象外とする。

---

### 2. データ管理と更新の特性およびその制約

管理対象である「パーツ情報」は、その性質上、**更新頻度が少ない**と想定する。
* この特性を活かし、Webアプリケーションからのデータ参照は**読み出し専用**とし、データの更新は**特定の限られた環境**でのみ行われるものとする。

---

### 3. データベースの運用方法とセキュリティ上の考慮点

「更新頻度が少ない」「読み出し専用」、そして「無料で運用したい」という要件を満たすため、**サーバー側のデータベースは静的に運用**する。動的なデータベースサーバーの構築・管理は行わない。
* データベースは、**単一ファイルで管理できるSQLite**を採用する。これは、静的ホスティング環境との親和性が高く、Gitでのバージョン管理に適しているから。
* 具体的には、SQLiteデータベースファイルを**GitHubでバージョン管理**し、Webアプリケーションがこれをデータソースとして利用する。これにより、変更履歴の管理やバックアップが容易になる。
* **非常に重要な注意点として、GitHubリポジトリに置かれたデータベースファイルは一般に公開される**。そのため、**個人情報や機密情報など、プライバシーに関わるデータや公開されては困るデータは一切含めるべきではない。**
* データの更新は、ローカル環境でSQLiteデータベースファイルを直接編集し、そのファイルを**GitHubリポジトリに上書きしてプッシュ**することで実現する。
* GitHubに新しいデータベースファイルがプッシュされるまでは、Webアプリケーション上には**更新されたデータは反映されない**。

---

### 4. ホスティング環境と運用モードの自動切り替え

「静的なホスティング」「GitHubでのデータベース管理」、そして「無料で運用したい」という要件をすべて満たすため、Webアプリケーションは**GitHub Pagesで運用**する。これにより、GitHubリポジトリのコンテンツを直接Webサイトとして無料で公開でき、デプロイの手間が省ける。
* GitHub Pagesのホスティング環境からアクセスする**リモート環境**では、データベースが一般公開される特性と更新頻度が低いという前提に基づき、ユーザーは**読み出し専用のUI**のみを利用できる。データの追加、編集、削除は行えない。
* 一方、GitHubのリポジトリをクローンし、**ローカル環境**（ローカルホスト）でアプリケーションを実行する場合は、パーツデータを**追加・編集・削除するためのUI**を提供する。これにより、限定された環境でのデータ更新が可能となる。
* アプリケーションは、動作している環境（ローカルホストかGitHub Pagesか）を**自動的に判別**し、それに応じて利用可能なUIの振る舞いを切り替える。

---

## アプリケーション設計仕様

### 1. UIの共通仕様（リモート/ローカルモード共通）

* **検索機能**: 「カテゴリ検索」と「キーワード検索」のタブで切り替えられる。
    * **カテゴリ検索タブ**: 「コンデンサ」「抵抗」「ダイオード」「トランジスタ」「オペアンプ」「マイコン」「メモリ」などのカテゴリボタンを表示する。いずれかのボタンを選択すると、そのカテゴリに属するパーツの一覧が表示される。表示エリアを節約するため、カテゴリボタンは表示しないようにする。
    * **キーワード検索タブ**: キーワード入力欄と「検索」ボタンを表示する。入力されたキーワードでパーツ情報を全文検索し、結果を一覧表示する。キーワードが未入力の場合は、すべてのパーツを一覧表示する。
* **パーツ一覧表示**:
    * カテゴリ検索、キーワード検索どちらの結果も、同じフォーマットでパーツ一覧を表示する。
    * 画面の制約を考慮し、全カラムは表示しない。表示カラムは左から「**在庫数**」(quantity)、「**パーツ名**」(parts tableのname)、「**型番**」(part_number)、「**外形**」(package)、「**タイプ**」(logic_family)、「**詳細**」(description)に限定する。()内はカラム名。
    * 各カラムのヘッダーには、昇順・降順ソートを示すアイコンを配置する。アイコン選択で、そのカラムを基準としたソート結果を再表示する。
    * パーツ情報に「データシートのURL」が含まれる場合、「パーツ名」は当該URLへのハイパーリンクとして表示する。
* **パーツ詳細表示**:
    * 各パーツの行には「詳細表示」ボタンを配置する。
    * 「詳細表示」ボタンを押すと、ポップアップダイアログが表示され、選択されたパーツの**すべてのカラム情報**を表示する。

### 2. ローカルモード専用のUI追加機能

GitHubリポジトリをクローンし、ローカル環境で実行した場合にのみ、以下のUIが追加される。

* **パーツ一覧での在庫数直接編集**:
    * パーツ一覧のカラム「在庫数」は、直接数値を入力して変更できるようにする。
* **パーツ詳細情報の編集・削除**:
    * 各パーツの「詳細表示」ボタンで開くダイアログで、**すべてのカラム情報が編集可能**になる。
    * 「詳細表示」ボタンに加え、**「削除」ボタン**が追加される。このボタンを押すと、確認ダイアログが表示された後、そのパーツが在庫情報と共にデータベースから削除される。
* **パーツの新規追加**:
    * 検索結果表示領域とは別に、「**パーツの追加**」ボタンを追加する。
    * このボタンを押すと、すべてのカラムの入力が可能なダイアログが表示され、入力された情報で新しいパーツレコードがローカルデータベースに追加される。
* **変更の管理と同期**:
    * パーツの追加、パーツ情報の変更、パーツの削除操作を行った際に、「**取り消し**」ボタンと「**同期**」ボタンを表示する。
        * 「**取り消し**」ボタン：それまでの追加・修正・削除操作をすべてキャンセルし、データを元の状態に戻す。
        * 「**同期**」ボタン：ローカルデータベースでの追加・修正・削除操作を確定し、SQLiteデータベースファイルとしてユーザーのローカル環境にダウンロードする。このダウンロードされたファイルを手動でGitHubにプッシュすることで、Webアプリケーションに反映させる。

### 3. 環境判別とUIの切り替え

* アプリケーション起動時に、現在の実行環境がGitHub Pagesなどのリモート環境か、ローカルホスト（開発環境）かを自動的に判別する。
* この判別結果に基づいて、上記で定義されたリードオンリーUI（リモート）または編集機能付きUI（ローカル）のどちらを表示するかを切り替える。

---

## データベース管理仕様

### 1. アプリケーションとデータベースの連携

* Webアプリケーションは起動時、GitHub PagesからダウンロードしたSQLiteデータベースファイル（またはローカルに存在するファイル）を**ブラウザのメモリ上に読み込み**、これを**ローカルDB**として管理する。
* パーツの追加・編集・削除といったすべてのデータ操作は、この**メモリ上のローカルDB**に対して行われる。
* ローカルDBに対する変更をキャンセルする場合、「取り消し」ボタンが押された際に、メモリ上のローカルDBを破棄し、サーバー（GitHub Pages）上の元のSQLiteデータベースファイルを再度読み込み直すことで、初期状態に戻す。

### 2. SQLite操作ライブラリ

* SQLiteデータベースの操作（読み込み、クエリ実行、変更）には、JavaScriptでSQLiteを扱うためのライブラリである**sql.js**を使用する。

### 3. データの同期とダウンロード

* 「同期」ボタンが押されたら、メモリ上のローカルDBの現在の状態を、**File API**を使用してSQLiteデータベースファイル（例: `parts.db`）としてユーザーのローカル環境にダウンロードする。

### 4. データベーススキーマ

本システムで利用するデータベースのスキーマは以下の通りとする。

```sql
-- 部品カテゴリ（階層構造対応：親IDを持つ）
CREATE TABLE categories (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    parent_id INTEGER,
    display_order INTEGER DEFAULT 1000,        -- 表示順序（小さい値が先に表示）
    FOREIGN KEY (parent_id) REFERENCES categories(id)
);

-- 電子部品情報（型番や分類、基本情報）
CREATE TABLE parts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,                -- 部品の名前（例: 74HC00, 10kΩ）
    category_id INTEGER,               -- 紐付けるカテゴリ
    manufacturer TEXT,                 -- メーカー名
    part_number TEXT,                  -- 型番
    package TEXT,                      -- パッケージ（例: DIP, SMD, TO-220）
    voltage_rating TEXT,               -- 耐圧など（例: 50V）
    current_rating TEXT,               -- 電流制限など（例: 1A）
    power_rating TEXT,                 -- 定格電力（例: 0.25W）
    tolerance TEXT,                    -- 誤差（例: ±1%）
    logic_family TEXT,                 -- LS, HC などロジックファミリ（必要に応じて）
    description TEXT,                  -- 説明・備考
    datasheet_url TEXT,                -- データシートへのリンク
    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (category_id) REFERENCES categories(id)
);

-- 在庫管理（購入履歴や残数）
CREATE TABLE inventory (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    part_id INTEGER NOT NULL,
    quantity INTEGER NOT NULL DEFAULT 0,        -- 在庫数
    location TEXT,                              -- 保管場所（引き出し番号など）
    purchase_date TEXT,                         -- 購入日
    shop TEXT,                                  -- 購入先（秋月、aitendo、AliExpressなど）
    price_per_unit REAL,                        -- 単価
    currency TEXT DEFAULT 'JPY',                -- 通貨（必要に応じて）
    memo TEXT,
    FOREIGN KEY (part_id) REFERENCES parts(id)
);
```